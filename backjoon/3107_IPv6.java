import java.io.*;
import java.util.*;

/*
 * 스포일러 방지를 위해 맨 밑에 주석으로 풀이가 있습니다.
 * */


public class Main {

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        char[] input = br.readLine().toCharArray();
        char[] answer = "0000:0000:0000:0000:0000:0000:0000:0000".toCharArray();

        int count = 0;
        int tmi = 1000;
        for(int i=0; i< input.length; i++){
            if(input[i]==':') count++;
        }

        if(count >7){
            char[] tmp = new char[input.length-1];
            int index = 0;
            for(int i=0; i< input.length; i++){

                if(i > 0 && input[i-1]==':' && input[i]==':'){
                    continue;
                }
                tmp[index++] = input[i];
            }
            input = tmp;
        }

        int diff = 7 - count;
        int index = answer.length-1;

        for(int j=input.length-1; j>=0; j--){

            if(input[j]==':'){

                while(answer[index] != ':'){
                    index--;
                }
                if(j < input.length-1 && input[j+1]==':' && diff > 0){
                    index -= (diff)*5;
                    diff = 0;
                }

                index--;
            }else{
                answer[index--] = input[j];
            }
        }
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<answer.length; i++){
            sb.append(answer[i]);
        }

        System.out.println(sb.toString());
    }

}

/*
 * 문자열 문제
 *
 * 이 문제는 어떤 한 알고리즘으로만 푸는 문제보단 원하는 방법으로 구현하면 되는 문제 같아서 여러 풀이 방법이 존재할 것이라고 생각합니다.
 * 저는 투포인터를 사용하였고, 크게는 다음과 같은 로직으로 문제를 풀이해나갔습니다.
 *
 * 1. 우선 "0000:0000:0000:0000:0000:0000:0000:0000"의 answer 문자 배열을 준비한다.
 * 2. 입력으로 들어온 문자 배열과 위의 문자배열을 끝 부분부터 포인터로 가르키며 answer에 값을 입력된 값으로 바꿔준다.
 * 3. 0이 생략되었을 수 있어서 입력이 ':'을 가르키면 answer의 포인터도 가장 가까운 ':'을 가르키게 만들어준다.
 *
 * 그런데 저희가 고려해야하는 해당 문제의 포인트는 다음과 같습니다.
 * 1. 앞 자리의 0은 생략할 수 있다. -> ("0000"의 경우 {"000", "00", "0", ""}으로 표현 가능)
 * 2. 0으로 이루어진 그룹이 한개 이상일 때 "::"으로 바꾸기가 가능하다. 단, 한번만 할 수 있다.
 *
 * 그러면 위의 포인트로 알 수 있는 점은
 * 1. 입력으로 들어오는 16진수 부분은 4자보다 적을 수 있다.
 * 2. 입력으로 들어오는 ":"의 갯수는 7개보다 적거나 많을 수 있다.
 *
 * 저는 투포인터의 판별 기준을 ':'으로 했습니다. 왜냐하면 입력이 어떻게 들어오건 콜론(':')은 7개가 정상입니다.
 * 7개 보다 적다는 뜻은 2개 이상의 그룹이 생략되었다는 뜻이고, 8개라면 "0000"으로 구성된 한개의 그룹만 "::"이 되었다는 것을 알 수 있습니다.
 *
 * 그러면 먼저 ':'의 갯수를 세어줍니다.
 * 만약 7개 이상이면 쓸데 없는 ':' 하나가 늘어났으므로 그 부분을 제거해줍니다.
 *
 * 7개 미만이라면 그 차이 값을 7 - count로 구해줍니다.
 * 이후 투 포인터를 진행하다가 연속으로 ::을 만났을 때 answer의 포인터를 5칸 앞으로 당겨주면 됩니다.
 *
 * 이러한 방법을 코드로 구현하여 풀이하였습니다.
 * 말로는 설명이 어려워서 작동되는 방식을 아래 예시로 나타내보았습니다.
 *
 * ================================ 아래는 예시 =====================================
 *
 * 예를 들어 다음과 같은 입력이 들어왔다면
 * "::1"
 *
 * 먼저 input을 순회하며 ':'의 갯수를 세어줍니다.
 * 원래 있어야하는 콜론 갯수 7에 세어본 갯수 2를 빼주면  7 - 2 = 5 로 콜론이 5개가 스킵되었다는 것을 알 수 있습니다.
 * 그렇다면 나중에 ":"이 2번 중복으로 나올 때 5*5 만큼 answer의 index를 왼쪽으로 옮겨주면됩니다.
 *
 * 이제 포인터를 적용해보면 초기에는 다음 상태입니다.
 * ::1 (index = 2)
 * 0000:0000:0000:0000:0000:0000:0000:0000 (index = 38)
 *
 * input과 answer는 각각 맨 마지막 값을 포인터로 가르키고 있으므로 answer의 값을 수정한 후 왼쪽으로 옮겨주면 다음과 같이 됩니다.
 *                                      ↓
 * 0000:0000:0000:0000:0000:0000:0000:0001 (index = 37)

 * 다음으로 input의 다음 값은 ':'입니다. answer는 '0'을 가르키고 있으므로 ':'의 다음을 가르킬 때 까지 포인터를 옮겨줍니다.
 *                                  ↓
 * 0000:0000:0000:0000:0000:0000:0000:0001 (index = 33)
 *
 * 다음으로 input의 포인터를 왼쪽으로 옮겼는데 ':'가 또 나왔습니다.
 * answer를 먼저 다음 ':' 위치로 옮긴 후
 *                              ↓
 * 0000:0000:0000:0000:0000:0000:0000:0001 (index = 29)
 *
 * (7-2)*5 +1 만큼 옮겨줍니다.
 *    ↓
 * 0000:0000:0000:0000:0000:0000:0000:0001 (index = 3)
 *
 * 이후 input의 index가 0보다 적으니 이후의 값은 수정하지 않고 종료됩니다.
 *
 * */