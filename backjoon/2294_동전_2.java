import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

/*
 * 스포일러 방지를 위해 맨 밑에 주석으로 풀이가 있습니다.
 * */

public class Main {

    static int N, K;
    static int[][] dp;

    public static void main(String[] args) throws Exception {


        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        dp = new int[N+1][K+1];

        for(int i=1; i<=N; i++){
            int val = Integer.parseInt(br.readLine());

            for(int j=1; j<=K; j++){
                if(j-val==0){
                    dp[i][j] = 1;
                }
                else if(j-val>0 && dp[i][j-val]>0){
                    dp[i][j] = dp[i][j-val]+1;
                    if(dp[i-1][j]!=0) dp[i][j] = Math.min(dp[i][j], dp[i-1][j]);
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }

            }

        }

        System.out.println(dp[N][K] ==0 ? -1 : dp[N][K]);

    }
}

/*
 * 다이나믹 프로그래밍 문제
 *
 * 해당 문제는 이차원 배열로 메모이제이션을 사용하여 풀 수 있습니다.
 * 이 문제에서 동전의 구성이 같다면 경우의 수로 중복 카운팅 하지 않습니다.
 * 즉 1과 2 동전으로 4를 만든다고 할 때 (2+1+1)과 (1+2+1)과 (1+1+2)는 모두 하나로 칩니다.
 * 또한 같은 가치의 동전이 여러번 나올 수 있음을 유의해야합니다.
 *
 * 이 문제의 핵심은 메모이제이션으로 입력으로 주어진 값을 통해 1~K값 까지 '동전의 개수'를 이용하여 만들 수 있는 경우의 수 중
 * 동전을 사용한 값이 가장 작은 값을 기억하여 다음 번에도 사용한다는 점입니다.
 *
 * 예시로 다음과 같은 입력이 있다고 한다면
 * 2 6
 * 2
 * 3
 *
 * 우선 비어있는 2차원 배열을 만들어보겠습니다.
 *   0 1 2 3 4 5 6
 * 0 0 0 0 0 0 0 0
 * 2 0 0 0 0 0 0 0
 * 3 0 0 0 0 0 0 0
 *
 * 첫 번째 입력인 2를 통해 1~6까지 만들 수 있는 경우를 배열로 나타내보면 다음과 같습니다.
 *   0 1 2 3 4 5 6
 * 0 0 0 0 0 0 0 0
 * 2 0 0 1 0 2 0 3
 * 3 0 0 0 0 0 0 0
 *
 * 2를 통해 2, 4, 6을 만들 수 있고 이는 각각 2원 동전이 1개 2개 3개로 만들 수 있습니다.
 *
 * 이제 두 번째 입력인 3을 포함하여 1에서부터 6까지 만드는 경우를 배열로 만들면 다음과 같습니다.
 *   0 1 2 3 4 5 6
 * 0 0 0 0 0 0 0 0
 * 2 0 0 1 0 2 0 3
 * 3 0 0 1 1 2 2 2
 *
 * 3을 포함하게 되면 3을 만들 때 1개를 만들 수 있고 5를 만들때 {3,2}를 통해 두 개를 이용하여 만들 수 있고 {3,3}을 이용하여 6을 만들 수 있습니다.
 *
 * 위 결과에서 규칙성을 찾아보면 다음과 같습니다.
 * 바로 내 위의 인덱스 값은 이때까지 내가 구한 가장 작은 경우의 수를 뜻합니다.
 * 1. 현재 나와 같은 숫자일 때는 반드시 이때까지 구한 경우의 수 값은 1로 해줍니다. 왜냐하면 1개만 써서 만들 수 있는 것이 가장 이상적이기 때문입니다.
 * 2. 만약 인덱스를 빼도 그 값이 0이라서 못 만드는 경우 바로 위의 인덱스 값을 그대로 가져옵니다. ( 예 : 3으로는 2를 만들 수 없기에 2에서 만든 가장 작은 경우의 수를 그대로 가져왔습니다.)
 * 3. 지금 탐색한 값에 현재 나의 값을 뺀만큼의 인덱스가 가르키는 값에 +1을 해줍니다. ( 3으로 5를 만들 때 2의 인덱스를 찾아보니 1값이 있습니다. 그럼 2를 만드는 가장 적은 경우의 수는 1이고 여기 +1만 해주면 됩니다.)
 * 4. 만약 내 위의 인덱스 값이 0이 아니라면 비교를 통해 더 적은 값으로 갱신해줍니다.
 * ( 3으로 6을 만들 때는 {3,3}으로 2입니다. 그런데 3이전에 2에서는 6을 만들기 위해 {2,2,2} 3개가 필요했으므로 둘 중 값이 적은 값인 2로 갱신해줍니다.)
 *
 * 이 규칙들을 구현해주면 문제를 풀이할 수 있습니다.
 */